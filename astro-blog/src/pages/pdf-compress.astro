---
import Layout from "../layouts/Layout.astro";
const title = "PDF圧縮";
const apiBase = import.meta.env.PUBLIC_PDF_API_BASE || '';
const pageTitle = 'PDF圧縮｜履歴書・提出書類の容量を軽くする';
const pageDescription = '履歴書や提出書類、スキャナ・複合機・コンビニでスキャンしたPDFの容量を画質とのバランスを見ながら圧縮できます。サーバで圧縮処理を行い、元PDFは短時間のみ保存され一定時間後に自動削除されます。圧縮後ファイルも一定時間のみ保存され、自動削除されます。';
---
<Layout
  noSidebar
  pageTitle={pageTitle}
  metaDescription={pageDescription}
  pageHeading={title}
>
  <section class="rounded-2xl border border-gray-200 dark:border-gray-800 bg-gradient-to-br from-white to-blue-50/60 dark:from-gray-950 dark:to-gray-900 p-6 md:p-8">
    <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-6">
      <div class="max-w-xl space-y-3">
        <p class="text-gray-700 dark:text-gray-300 leading-relaxed">
          履歴書や提出書類のPDFを、画質とのバランスを見ながら圧縮できます。<br />
          サーバで圧縮処理を行い、元PDFと圧縮後ファイルは一定時間後に自動削除されます。<br />
          3候補のプレビューとサイズを見比べて、目的に合うものを選べます。
        </p>
        <div class="flex flex-wrap gap-2 text-xs text-gray-600 dark:text-gray-400">
          <span class="rounded-full bg-white/80 dark:bg-gray-900/80 px-3 py-1 ring-1 ring-gray-200 dark:ring-gray-700">無料・登録不要</span>
          <span class="rounded-full bg-white/80 dark:bg-gray-900/80 px-3 py-1 ring-1 ring-gray-200 dark:ring-gray-700">ブラウザで完結</span>
          <span class="rounded-full bg-white/80 dark:bg-gray-900/80 px-3 py-1 ring-1 ring-gray-200 dark:ring-gray-700">ファイルは一定時間後に自動削除</span>
        </div>
      </div>
      <div>
        <a href="#tool" class="inline-flex items-center rounded-md bg-blue-600 px-5 py-2.5 text-white hover:bg-blue-700">いますぐ圧縮する</a>
      </div>
    </div>
  </section>

  <section id="tool" class="card p-6 mt-8">
    <div class="flex items-start justify-between gap-4 mb-6">
      <div>
        <h2 class="text-lg font-semibold">PDF圧縮ツール</h2>
        <p class="text-sm text-gray-600 dark:text-gray-400">STEPに沿って進めるだけで、圧縮候補が表示されます。</p>
      </div>
      <span class="text-xs text-gray-500">対応ファイル: PDF / 最大50MB</span>
    </div>

    <div class="space-y-6">
      <div>
        <div class="text-xs font-semibold text-gray-500 mb-2">STEP 1 アップロード</div>
        <label class="block font-medium mb-1" for="pdfFile">PDFファイルを選択</label>
        <div class="flex flex-wrap items-center gap-3">
          <label for="pdfFile" class="inline-flex items-center rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer">
            ファイルを選択
          </label>
          <span id="fileInfo" class="text-sm text-gray-500">未選択</span>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf" class="sr-only" />
      </div>

      <div>
        <div class="text-xs font-semibold text-gray-500 mb-2">STEP 2 設定</div>
        <label class="block font-medium mb-1" for="maxSizeMb">上限サイズ（任意）</label>
        <div class="flex items-center gap-3">
          <input id="maxSizeMb" type="number" inputmode="decimal" step="0.1" min="0.1" class="w-40 border rounded px-3 py-2" placeholder="例：5" />
          <span class="text-sm text-gray-700 dark:text-gray-300">MB</span>
        </div>
        <p class="mt-1 text-xs text-gray-500">上限を入れると、条件を満たす候補にバッジが付きます。</p>
      </div>

      <div>
        <div class="text-xs font-semibold text-gray-500 mb-2">STEP 3 圧縮</div>
        <div class="flex items-center gap-3">
          <button id="compressBtn" class="rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 disabled:opacity-50" disabled>
            圧縮を開始
          </button>
        </div>
        <div id="statusBanner" class="hidden mt-3 rounded-md border px-4 py-3 text-sm">
          <span id="statusText"></span>
        </div>
        <div id="progressText" class="text-xs text-gray-500 mt-2"></div>
      </div>

      <details class="mt-2">
        <summary class="cursor-pointer select-none">詳細オプション</summary>
        <div class="mt-2 space-y-2">
          <label class="flex items-center gap-2">
            <input id="removeMetadata" type="checkbox" class="h-4 w-4" checked />
            <span class="text-sm">文書メタデータを削除（可能な場合）</span>
          </label>
          <label class="flex items-center gap-2">
            <input id="grayscale" type="checkbox" class="h-4 w-4" />
            <span class="text-sm">グレースケールに変換（容量を小さく）</span>
          </label>
        </div>
      </details>
    </div>
  </section>

  <section id="resultCard" class="card p-6 mt-6 hidden">
    <div class="flex items-start justify-between gap-4 mb-4">
      <div>
        <h2 class="text-lg font-semibold">圧縮結果</h2>
        <p id="resultStatus" class="text-sm text-gray-600 dark:text-gray-400">圧縮結果はここに表示されます。</p>
      </div>
    </div>
    <div id="preview" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
  </section>

  <section class="card p-6 mt-8">
    <h2 class="text-xl font-semibold mb-3">解説・安全性</h2>
    <div class="rounded-md border border-gray-200 dark:border-gray-800 bg-gray-50/60 dark:bg-gray-900/40 p-4 text-sm text-gray-700 dark:text-gray-300 mb-5">
      まずは「ファイル選択 → 圧縮開始」だけでOKです。3候補のサイズとプレビューを見て、提出条件や読みやすさに合うものを選んでください。
    </div>

    <h3 class="text-base font-semibold mb-2">役立つ場面</h3>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-5 space-y-1">
      <li>履歴書・職務経歴書をメール添付で送りたい（容量制限に合わせたい）</li>
      <li>学校・保育園・役所にPDF提出が必要（指定サイズがある）</li>
      <li>スキャナや複合機でスキャンしたPDFが重い（画像ベースのPDF）</li>
    </ul>

    <h3 class="text-base font-semibold mb-2">注意点・制限</h3>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-5 space-y-1">
      <li>圧縮後の画質は元に戻せません。元PDFは手元に保存しておくことをおすすめします。</li>
      <li>内容によってはサイズがあまり小さくならないことがあります。</li>
      <li>重要書類は送信・提出前に内容を確認してからご利用ください。</li>
      <li>通信環境によってはアップロードやダウンロードが失敗する場合があります。</li>
    </ul>

    <h3 class="text-base font-semibold mb-2">データの取り扱い</h3>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-5 space-y-1">
      <li>PDFは一時的にアップロードされ、サーバ側で圧縮処理を行います。</li>
      <li>元PDFは短時間のみ保存され、一定時間後に自動的に削除されます。</li>
      <li>圧縮後ファイルも一定時間のみ保存され、その後自動的に削除されます。</li>
    </ul>

    <h3 class="text-base font-semibold mb-2">よくある質問</h3>
    <dl class="text-gray-600 dark:text-gray-400 space-y-3">
      <div>
        <dt class="font-medium">Q. なぜ思ったほどサイズが小さくならないのですか？</dt>
        <dd class="text-sm">画像が少ないPDFや、すでに最適化されているPDFは効果が出にくいことがあります。</dd>
      </div>
      <div>
        <dt class="font-medium">Q. 画質はどのくらい落ちますか？</dt>
        <dd class="text-sm">候補ごとに差があるので、文字の読みやすさを基準に選んでください。</dd>
      </div>
      <div>
        <dt class="font-medium">Q. 提出書類に使っても大丈夫ですか？</dt>
        <dd class="text-sm">提出先の指定を満たせる場合に限り利用できます。必ず内容と見え方を確認してください。</dd>
      </div>
    </dl>
  </section>

  <script define:vars={{ apiBase }}>
    var API_BASE = apiBase || '';
    function api(path) {
      var b = API_BASE || '';
      if (b && b.charAt(b.length - 1) === '/') b = b.slice(0, -1);
      return b + path;
    }

    var fileInput = document.getElementById('pdfFile');
    var fileInfo = document.getElementById('fileInfo');
    var compressBtn = document.getElementById('compressBtn');
    var statusBanner = document.getElementById('statusBanner');
    var statusEl = document.getElementById('statusText');
    var progressText = document.getElementById('progressText');
    var preview = document.getElementById('preview');
    var resultCard = document.getElementById('resultCard');
    var resultStatus = document.getElementById('resultStatus');
    var maxSizeMb = document.getElementById('maxSizeMb');
    var activeOptions = null;
    var activeBaseName = null;
    var variantsState = [];
    var MAX_UPLOAD_BYTES = 50 * 1024 * 1024;
    var didScrollToResult = false;

    function setStatus(message, type) {
      if (!statusEl || !statusBanner) return;
      statusEl.textContent = message || '';
      if (!message) {
        statusBanner.classList.add('hidden');
        return;
      }
      statusBanner.classList.remove('hidden');
      statusBanner.classList.remove(
        'bg-blue-50','border-blue-200','text-blue-900',
        'bg-green-50','border-green-200','text-green-900',
        'bg-red-50','border-red-200','text-red-900'
      );
      if (type === 'success') {
        statusBanner.classList.add('bg-green-50','border-green-200','text-green-900');
      } else if (type === 'error') {
        statusBanner.classList.add('bg-red-50','border-red-200','text-red-900');
      } else {
        statusBanner.classList.add('bg-blue-50','border-blue-200','text-blue-900');
      }
    }

    function setResultStatus(message) {
      if (!resultStatus) return;
      resultStatus.textContent = message || '';
    }

    function formatBytes(bytes) {
      if (!isFinite(bytes)) return '';
      var sizes = ['B','KB','MB','GB'];
      var i = 0;
      while (bytes >= 1024 && i < sizes.length - 1) { bytes /= 1024; i++; }
      var places = (bytes < 10 && i > 0) ? 1 : 0;
      return String(bytes.toFixed(places)) + ' ' + sizes[i];
    }

    function formatMb(value) {
      if (!isFinite(value)) return '';
      var rounded = Math.round(value * 10) / 10;
      return (rounded % 1 === 0) ? String(Math.trunc(rounded)) : String(rounded);
    }

    function formatPercent(value) {
      if (!isFinite(value)) return '';
      return String(Math.round(value));
    }

    function parseMaxSizeBytes() {
      if (!maxSizeMb) return null;
      var mb = Number(maxSizeMb.value);
      if (!isFinite(mb) || mb <= 0) return null;
      return mb * 1024 * 1024;
    }

    if (fileInput) {
      fileInput.addEventListener('change', function () {
        if (preview) preview.innerHTML = '';
        var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (compressBtn) compressBtn.disabled = !f;
        if (fileInfo) fileInfo.textContent = f ? (f.name + ' — ' + formatBytes(f.size)) : '未選択';
        setStatus('', 'info');
        if (progressText) progressText.textContent = '';
        if (resultStatus) setResultStatus('圧縮結果はここに表示されます。');
        if (f && f.size > MAX_UPLOAD_BYTES) {
          if (compressBtn) compressBtn.disabled = true;
          setStatus('ファイルサイズが大きすぎます。最大50MBまでです。', 'error');
        }
      });
    }

    function postJSON(url, data) {
      return fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(data)
      }).then(function (res) {
        if (res.ok) return res.json();
        return res.text().then(function (t) {
          var err = new Error('リクエストに失敗しました: ' + res.status + (t ? (' ' + t) : ''));
          err.status = res.status;
          err.body = t;
          throw err;
        });
      });
    }

    function sleep(ms) { return new Promise(function (r) { setTimeout(r, ms); }); }

    async function withBackoff(task, options) {
      options = options || {};
      var retries = (options.retries == null ? 4 : options.retries);
      var base = options.base || 400; // ms
      var factor = options.factor || 2;
      var max = options.max || 5000; // ms
      for (var attempt = 0; attempt <= retries; attempt++) {
        try {
          return await task(attempt + 1);
        } catch (e) {
          var status = e && e.status;
          var retryable = (status === 429) || (status >= 500 && status < 600) || (status == null);
          if (attempt === retries || !retryable) { throw e; }
          var delay = Math.min(max, base * Math.pow(factor, attempt));
          var wait = Math.floor(Math.random() * delay); // full jitter
          setStatus('再試行まで ' + Math.ceil(wait/1000) + ' 秒（' + (attempt+2) + '/' + (retries+1) + ' 回目）', 'info');
          await sleep(wait);
        }
      }
    }

    function uploadToS3Post(sign, file, onProgress) {
      return new Promise(function (resolve, reject) {
        if (!sign || !sign.url || !sign.fields) {
          reject(new Error('アップロード情報が不正です'));
          return;
        }
        var xhr = new XMLHttpRequest();
        xhr.open('POST', sign.url);
        xhr.upload.onprogress = function (e) {
          if (!e.lengthComputable) return;
          var pct = Math.round((e.loaded / e.total) * 100);
          if (onProgress) onProgress(pct);
        };
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) resolve(null);
          else {
            var detail = xhr.responseText ? (' ' + xhr.responseText) : '';
            reject(new Error('アップロードに失敗しました: ' + xhr.status + detail));
          }
        };
        xhr.onerror = function () { reject(new Error('アップロード中に通信エラーが発生しました')); };
        var formData = new FormData();
        Object.keys(sign.fields).forEach(function (key) {
          formData.append(key, sign.fields[key]);
        });
        formData.append('file', file);
        xhr.send(formData);
      });
    }

    function downloadSignedUrl(url, filename) {
      setStatus('ダウンロード準備中...', 'info');
      return fetch(url, { method: 'GET' })
        .then(function (res) {
          if (!res.ok) throw new Error('ダウンロードに失敗しました: ' + res.status);
          return res.blob();
        })
        .then(function (blob) {
          var link = document.createElement('a');
          var urlObj = URL.createObjectURL(blob);
          link.href = urlObj;
          if (filename) link.download = filename;
          document.body.appendChild(link);
          link.click();
          setTimeout(function () { URL.revokeObjectURL(urlObj); if (link.parentNode) link.parentNode.removeChild(link); }, 1000);
          setStatus('ダウンロードを開始しました。', 'success');
        });
    }

    function pickRecommendedKey(variants, maxBytes) {
      if (!variants || !variants.length) return null;
      if (!maxBytes) return 'balanced';
      var within = variants.filter(function (v) { return isFinite(v.outputSizeBytes) && v.outputSizeBytes <= maxBytes; });
      if (within.length > 0) {
        var order = ['balanced', 'high_quality', 'high_compression'];
        for (var i = 0; i < order.length; i++) {
          var found = within.find(function (v) { return v.key === order[i]; });
          if (found) return found.key;
        }
      }
      var min = null;
      for (var j = 0; j < variants.length; j++) {
        if (!isFinite(variants[j].outputSizeBytes)) continue;
        if (!min || variants[j].outputSizeBytes < min.outputSizeBytes) min = variants[j];
      }
      return min ? min.key : variants[0].key;
    }

    function renderVariants(variants, originalSizeBytes, maxBytes, baseName) {
      if (!preview) return;
      preview.innerHTML = '';
      var recommendedKey = pickRecommendedKey(variants, maxBytes);
      var suffixMap = { high_quality: 'hq', balanced: 'balanced', high_compression: 'small' };
      var maxMbLabel = maxBytes ? (formatMb(maxBytes / 1024 / 1024) + 'MB以下') : '';

      variants.forEach(function (variant) {
        var card = document.createElement('div');
        card.className = 'border rounded-lg p-4 space-y-2';

        var titleRow = document.createElement('div');
        titleRow.className = 'flex items-center justify-between gap-2';
        var title = document.createElement('div');
        title.className = 'text-base font-semibold';
        title.textContent = variant.labelJa || '';
        titleRow.appendChild(title);

        var badges = document.createElement('div');
        badges.className = 'flex items-center gap-2';
        if (maxBytes && isFinite(variant.outputSizeBytes) && variant.outputSizeBytes <= maxBytes) {
          var okBadge = document.createElement('span');
          okBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-800';
          okBadge.textContent = maxMbLabel;
          badges.appendChild(okBadge);
        }
        if (variant.key === recommendedKey) {
          var recBadge = document.createElement('span');
          recBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800';
          recBadge.textContent = 'おすすめ';
          badges.appendChild(recBadge);
        }
        titleRow.appendChild(badges);
        card.appendChild(titleRow);

        var sizeText = document.createElement('div');
        sizeText.className = 'text-sm text-gray-600 dark:text-gray-400';
        if (isFinite(variant.outputSizeBytes)) {
          sizeText.textContent = '圧縮後サイズ: ' + formatBytes(variant.outputSizeBytes);
        } else if (variant.state === 'pending') {
          sizeText.textContent = '圧縮中...';
        } else {
          sizeText.textContent = '圧縮に失敗しました。';
        }
        card.appendChild(sizeText);

        if (isFinite(originalSizeBytes) && originalSizeBytes > 0 && isFinite(variant.outputSizeBytes)) {
          var ratio = (1 - (variant.outputSizeBytes / originalSizeBytes)) * 100;
          var ratioText = document.createElement('div');
          ratioText.className = 'text-sm text-gray-600 dark:text-gray-400';
          ratioText.textContent = '削減率: ' + formatPercent(ratio) + '%';
          card.appendChild(ratioText);
        }

        if (variant.previewUrl) {
          var img = document.createElement('img');
          img.src = variant.previewUrl;
          img.alt = variant.labelJa + 'のプレビュー';
          img.className = 'w-full rounded border';
          card.appendChild(img);
        } else if (variant.state === 'pending') {
          var waiting = document.createElement('div');
          waiting.className = 'text-sm text-gray-500';
          waiting.textContent = 'プレビューを生成中...';
          card.appendChild(waiting);
        } else if (variant.state === 'error') {
          var noPreview = document.createElement('div');
          noPreview.className = 'text-sm text-gray-500';
          noPreview.textContent = 'プレビューは表示できません';
          card.appendChild(noPreview);
        } else {
          var noPreview = document.createElement('div');
          noPreview.className = 'text-sm text-gray-500';
          noPreview.textContent = 'プレビューは準備中';
          card.appendChild(noPreview);
        }

        if (variant.state === 'error' && variant.errorMessage) {
          var errText = document.createElement('div');
          errText.className = 'text-xs text-red-600';
          errText.textContent = 'エラー: ' + variant.errorMessage;
          card.appendChild(errText);
        }

        if (variant.downloadUrl) {
          var btn = document.createElement('button');
          btn.className = 'rounded-md px-3 py-2 bg-blue-600 text-white hover:bg-blue-700';
          btn.textContent = 'ダウンロード';
          btn.dataset.url = variant.downloadUrl || '';
          var suffix = suffixMap[variant.key] || 'compressed';
          btn.dataset.filename = baseName ? (baseName + '.' + suffix + '.pdf') : '';
          btn.addEventListener('click', function () {
            if (!btn.dataset.url) return;
            downloadSignedUrl(btn.dataset.url, btn.dataset.filename || undefined)
              .catch(function (err) {
                console.error(err);
                setStatus('エラー: ' + (err && err.message || err), 'error');
              });
          });
          card.appendChild(btn);
        }

        if (variant.state === 'error' && typeof variant.onRetry === 'function') {
          var retryBtn = document.createElement('button');
          retryBtn.className = 'rounded-md px-3 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800';
          retryBtn.textContent = '再試行';
          retryBtn.addEventListener('click', function () {
            variant.onRetry();
          });
          card.appendChild(retryBtn);
        }

        preview.appendChild(card);
      });
    }

    if (compressBtn) {
      compressBtn.addEventListener('click', function () {
        var f = (fileInput && fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (!f) return;
        if (f.size > MAX_UPLOAD_BYTES) {
          setStatus('ファイルサイズが大きすぎます。最大50MBまでです。', 'error');
          if (compressBtn) compressBtn.disabled = true;
          return;
        }
        if (!API_BASE) {
          setStatus('APIの設定が見つかりません。PUBLIC_PDF_API_BASE を設定してください。', 'error');
          return;
        }
        compressBtn.disabled = true;
        setStatus('アップロードURLを取得中...', 'info');
        if (progressText) progressText.textContent = '';
        if (preview) preview.innerHTML = '';
        if (resultCard) resultCard.classList.remove('hidden');
        if (resultStatus) setResultStatus('圧縮結果を準備しています。');
        didScrollToResult = false;
        withBackoff(function () { return postJSON(api('/sign-upload'), {
          filename: f.name,
          contentType: f.type || 'application/pdf',
          contentLength: f.size
        }); }, { retries: 5, base: 500, max: 6000 }).then(function (sign) {
          setStatus('アップロード中...', 'info');
          return uploadToS3Post(sign, f, function (pct) {
            if (progressText) progressText.textContent = 'アップロード: ' + pct + '%';
          }).then(function () { return sign; });
        }).then(function (sign) {
          setStatus('圧縮中...（3件中 0件完了）', 'info');
          var rmEl = document.getElementById('removeMetadata');
          var gsEl = document.getElementById('grayscale');
          activeOptions = {
            removeMetadata: !!(rmEl && rmEl.checked),
            grayscale: !!(gsEl && gsEl.checked),
          };
          activeBaseName = f.name.replace(/\.pdf$/i, '');
          variantsState = [
            { key: 'high_quality', labelJa: '高画質', level: 1, state: 'pending' },
            { key: 'balanced', labelJa: '標準', level: 2, state: 'pending' },
            { key: 'high_compression', labelJa: '高圧縮', level: 3, state: 'pending' },
          ];
          renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);

          function updateStatus() {
            if (!statusEl) return;
            var doneCount = variantsState.filter(function (v) { return v.state !== 'pending'; }).length;
            setStatus('圧縮中...（3件中 ' + doneCount + '件完了）', 'info');
          }

          function normalizeDownloadUrl(resp) {
            return resp && (resp.downloadUrl || resp.download_url) || null;
          }

          function normalizePreviewUrl(resp) {
            return resp && (resp.previewUrl || resp.preview_url) || null;
          }

          function compressOne(level) {
            return withBackoff(function () {
              return postJSON(api('/compress'), {
                bucket: sign.bucket,
                key: sign.objectKey,
                level: level,
                removeMetadata: activeOptions.removeMetadata,
                grayscale: activeOptions.grayscale,
                keepSource: true
              });
            }, { retries: 5, base: 700, max: 8000 });
          }

          function attachRetry(variant) {
            variant.onRetry = function () {
              variant.state = 'pending';
              variant.errorMessage = null;
              variant.downloadUrl = null;
              variant.outputSizeBytes = NaN;
              variant.previewUrl = null;
              renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
              setStatus('再試行中...', 'info');
              compressOne(variant.level).then(function (resp) {
                var downloadUrl = normalizeDownloadUrl(resp);
                if (!downloadUrl) throw new Error('ダウンロード情報が取得できませんでした。');
                variant.state = 'success';
                variant.downloadUrl = downloadUrl;
                variant.outputSizeBytes = resp && resp.outputSizeBytes;
                variant.previewUrl = normalizePreviewUrl(resp);
                renderVariants(variantsState, resp.originalSizeBytes || f.size, parseMaxSizeBytes(), activeBaseName);
              }).catch(function (err) {
                variant.state = 'error';
                variant.errorMessage = (err && err.message) ? err.message : '不明なエラー';
                renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
              }).finally(function () {
                updateStatus();
              });
            };
          }

          variantsState.forEach(function (variant) { attachRetry(variant); });

          var requests = variantsState.map(function (variant) {
            return compressOne(variant.level).then(function (resp) {
              var downloadUrl = normalizeDownloadUrl(resp);
              if (!downloadUrl) throw new Error('ダウンロード情報が取得できませんでした。');
              variant.state = 'success';
              variant.downloadUrl = downloadUrl;
              variant.outputSizeBytes = resp && resp.outputSizeBytes;
              variant.previewUrl = normalizePreviewUrl(resp);
              renderVariants(variantsState, resp.originalSizeBytes || f.size, parseMaxSizeBytes(), activeBaseName);
            }).catch(function (err) {
              variant.state = 'error';
              variant.errorMessage = (err && err.message) ? err.message : '不明なエラー';
              renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
            }).finally(function () {
              updateStatus();
            });
          });

          return Promise.allSettled(requests).then(function () {
            if (statusEl) {
              var successCount = variantsState.filter(function (v) { return v.state === 'success'; }).length;
              if (successCount > 0) {
                setStatus('圧縮が完了しました。候補から選んでダウンロードしてください。', 'success');
                setResultStatus('圧縮結果を表示しました。候補から選んでダウンロードしてください。');
                if (!didScrollToResult && resultCard && typeof resultCard.scrollIntoView === 'function') {
                  didScrollToResult = true;
                  resultCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
              } else {
                setStatus('圧縮に失敗しました。時間をおいて再試行してください。', 'error');
                setResultStatus('圧縮に失敗しました。時間をおいて再試行してください。');
              }
            }
          });
        }).catch(function (err) {
          console.error(err);
          if (statusEl) {
            var message = err && err.message ? err.message : String(err || '');
            if (err && err.body) {
              try {
                var parsed = JSON.parse(err.body);
                if (parsed && parsed.message) message = parsed.message;
              } catch {}
            }
            if (err && err.status === 400 && message) {
              setStatus(message, 'error');
            } else {
              setStatus('エラー: ' + message, 'error');
            }
            setResultStatus('圧縮に失敗しました。時間をおいて再試行してください。');
          }
        }).finally(function () {
          var nextFile = (fileInput && fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
          compressBtn.disabled = !nextFile || nextFile.size > MAX_UPLOAD_BYTES;
        });
      });
    }
  </script>
</Layout>
