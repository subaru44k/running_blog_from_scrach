---
import Layout from "../layouts/Layout.astro";
const title = "PDF Compressor";
const apiBase = import.meta.env.PUBLIC_PDF_API_BASE || '';
---
<Layout noSidebar>
  <section class="card p-6">
    <h1 class="text-2xl font-bold mb-2">{title}</h1>
    <p class="text-gray-600 dark:text-gray-400 mb-6">
      Compress PDF files in your browser. Your files never leave your device.
    </p>

    <div class="space-y-4">
      <div>
        <label class="block font-medium mb-1" for="pdfFile">Select PDF file</label>
        <input id="pdfFile" type="file" accept="application/pdf" class="block w-full" />
        <p id="fileInfo" class="mt-1 text-sm text-gray-500"></p>
      </div>

      <div>
        <label class="block font-medium mb-1" for="level">Compression level</label>
        <div class="flex items-center gap-3">
          <input id="level" type="range" min="1" max="3" step="1" value="2" class="w-56" />
          <span id="levelLabel" class="text-sm text-gray-700 dark:text-gray-300">Medium</span>
        </div>
        <p class="mt-1 text-xs text-gray-500">Low = better quality, larger size. High = smaller size, lower quality.</p>
      </div>

      <div class="flex items-center gap-3">
        <button id="compressBtn" class="rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 disabled:opacity-50" disabled>
          Start Compression
        </button>
        <button id="downloadBtn" class="hidden rounded-md px-4 py-2 bg-blue-600 text-white hover:bg-blue-700">Download</button>
        <span id="status" class="text-sm text-gray-600 dark:text-gray-400"></span>
      </div>
      <div id="progressText" class="text-xs text-gray-500"></div>

      <details class="mt-2">
        <summary class="cursor-pointer select-none">Advanced options</summary>
        <div class="mt-2 space-y-2">
          <label class="flex items-center gap-2">
            <input id="removeMetadata" type="checkbox" class="h-4 w-4" checked />
            <span class="text-sm">Remove document metadata (when possible)</span>
          </label>
          <label class="flex items-center gap-2">
            <input id="grayscale" type="checkbox" class="h-4 w-4" />
            <span class="text-sm">Convert pages to grayscale (smaller size)</span>
          </label>
        </div>
      </details>

      <div id="preview" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    </div>
  </section>

  <script define:vars={{ apiBase }}>
    var API_BASE = apiBase || '';
    function api(path) {
      var b = API_BASE || '';
      if (b && b.charAt(b.length - 1) === '/') b = b.slice(0, -1);
      return b + path;
    }

    var fileInput = document.getElementById('pdfFile');
    var fileInfo = document.getElementById('fileInfo');
    var level = document.getElementById('level');
    var levelLabel = document.getElementById('levelLabel');
    var compressBtn = document.getElementById('compressBtn');
    var downloadBtn = document.getElementById('downloadBtn');
    var pendingDownloadUrl = null;
    var pendingFilename = null;
    var statusEl = document.getElementById('status');
    var progressText = document.getElementById('progressText');
    var preview = document.getElementById('preview');

    function levelText(v) { return (v <= 1 ? 'Low' : (v >= 3 ? 'High' : 'Medium')); }
    if (level && levelLabel) {
      levelLabel.textContent = levelText(Number(level.value));
      level.addEventListener('input', function () { levelLabel.textContent = levelText(Number(level.value)); });
    }

    function formatBytes(bytes) {
      if (!isFinite(bytes)) return '';
      var sizes = ['B','KB','MB','GB'];
      var i = 0;
      while (bytes >= 1024 && i < sizes.length - 1) { bytes /= 1024; i++; }
      var places = (bytes < 10 && i > 0) ? 1 : 0;
      return String(bytes.toFixed(places)) + ' ' + sizes[i];
    }

    if (fileInput) {
      fileInput.addEventListener('change', function () {
        if (preview) preview.innerHTML = '';
        var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (compressBtn) compressBtn.disabled = !f;
        if (fileInfo) fileInfo.textContent = f ? (f.name + ' â€” ' + formatBytes(f.size)) : '';
        if (statusEl) statusEl.textContent = '';
        if (downloadBtn) downloadBtn.classList.add('hidden');
        if (progressText) progressText.textContent = '';
      });
    }

    function postJSON(url, data) {
      return fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(data)
      }).then(function (res) {
        if (res.ok) return res.json();
        return res.text().then(function (t) {
          var err = new Error('Request failed: ' + res.status + (t ? (' ' + t) : ''));
          err.status = res.status;
          err.body = t;
          throw err;
        });
      });
    }

    function sleep(ms) { return new Promise(function (r) { setTimeout(r, ms); }); }

    async function withBackoff(task, options) {
      options = options || {};
      var retries = (options.retries == null ? 4 : options.retries);
      var base = options.base || 400; // ms
      var factor = options.factor || 2;
      var max = options.max || 5000; // ms
      for (var attempt = 0; attempt <= retries; attempt++) {
        try {
          return await task(attempt + 1);
        } catch (e) {
          var status = e && e.status;
          var retryable = (status === 429) || (status >= 500 && status < 600) || (status == null);
          if (attempt === retries || !retryable) { throw e; }
          var delay = Math.min(max, base * Math.pow(factor, attempt));
          var wait = Math.floor(Math.random() * delay); // full jitter
          if (statusEl) statusEl.textContent = 'Retrying in ' + Math.ceil(wait/1000) + 's... (attempt ' + (attempt+2) + '/' + (retries+1) + ')';
          await sleep(wait);
        }
      }
    }

    function uploadToS3(url, file, onProgress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('PUT', url);
        xhr.setRequestHeader('Content-Type', file.type || 'application/pdf');
        xhr.upload.onprogress = function (e) {
          if (!e.lengthComputable) return;
          var pct = Math.round((e.loaded / e.total) * 100);
          if (onProgress) onProgress(pct);
        };
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) resolve(null);
          else reject(new Error('S3 upload failed: ' + xhr.status));
        };
        xhr.onerror = function () { reject(new Error('Network error during S3 upload')); };
        xhr.send(file);
      });
    }

    if (compressBtn) {
      compressBtn.addEventListener('click', function () {
        var f = (fileInput && fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (!f) return;
        if (!API_BASE) {
          if (statusEl) statusEl.textContent = 'API base is not configured. Set PUBLIC_PDF_API_BASE.';
          return;
        }
        compressBtn.disabled = true;
        if (statusEl) statusEl.textContent = 'Requesting upload URL...';
        if (progressText) progressText.textContent = '';
        withBackoff(function () { return postJSON(api('/sign-upload'), {
          filename: f.name,
          contentType: f.type || 'application/pdf'
        }); }, { retries: 5, base: 500, max: 6000 }).then(function (sign) {
          if (statusEl) statusEl.textContent = 'Uploading to S3...';
          return uploadToS3(sign.uploadUrl, f, function (pct) {
            if (progressText) progressText.textContent = 'Upload: ' + pct + '%';
          }).then(function () { return sign; });
        }).then(function (sign) {
          if (statusEl) statusEl.textContent = 'Starting compression...';
          var rmEl = document.getElementById('removeMetadata');
          var gsEl = document.getElementById('grayscale');
          return withBackoff(function () { return postJSON(api('/compress'), {
            bucket: sign.bucket,
            key: sign.objectKey,
            level: Number(level && level.value || 2),
            removeMetadata: !!(rmEl && rmEl.checked),
            grayscale: !!(gsEl && gsEl.checked)
          }); }, { retries: 5, base: 700, max: 8000 });
        }).then(function (resp) {
          if (resp.downloadUrl && downloadBtn) {
            pendingDownloadUrl = resp.downloadUrl;
            var base = f.name.replace(/\.pdf$/i, '');
            pendingFilename = base + '.compressed.pdf';
            downloadBtn.classList.remove('hidden');
            if (statusEl) statusEl.textContent = 'Done. Click Download to save the compressed PDF.';
          } else if (statusEl) {
            statusEl.textContent = 'Compression finished. No downloadUrl returned.';
          }
        }).catch(function (err) {
          console.error(err);
          if (statusEl) statusEl.textContent = 'Error: ' + (err && err.message || err);
        }).finally(function () {
          compressBtn.disabled = !fileInput || !(fileInput.files && fileInput.files[0]);
        });
      });
    }

    if (downloadBtn) {
      downloadBtn.addEventListener('click', function () {
        if (!pendingDownloadUrl) return;
        if (statusEl) statusEl.textContent = 'Preparing download...';
        downloadBtn.disabled = true;
        fetch(pendingDownloadUrl, { method: 'GET' })
          .then(function (res) { if (!res.ok) throw new Error('Download failed: ' + res.status); return res.blob(); })
          .then(function (blob) {
            var link = document.createElement('a');
            var urlObj = URL.createObjectURL(blob);
            link.href = urlObj;
            if (pendingFilename) link.download = pendingFilename;
            document.body.appendChild(link);
            link.click();
            setTimeout(function () { URL.revokeObjectURL(urlObj); if (link.parentNode) link.parentNode.removeChild(link); }, 1000);
            if (statusEl) statusEl.textContent = 'Download started.';
          })
          .catch(function (err) {
            console.error(err);
            if (statusEl) statusEl.textContent = 'Error: ' + (err && err.message || err);
          })
          .finally(function () { downloadBtn.disabled = false; });
      });
    }
  </script>
</Layout>
