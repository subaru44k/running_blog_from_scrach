---
import Layout from "../layouts/Layout.astro";
const title = "PDF圧縮";
const apiBase = import.meta.env.PUBLIC_PDF_API_BASE || '';
const pageTitle = 'PDF圧縮｜履歴書・提出書類の容量を軽くする';
const pageDescription = '履歴書や提出書類、スマホで作成したPDFの容量を画質とのバランスを見ながら圧縮できます。サーバで圧縮処理を行い、元ファイルは完了後に削除、圧縮後は数時間のみ保存します。';
---
<Layout noSidebar pageTitle={pageTitle} metaDescription={pageDescription}>
  <section class="card p-6">
    <h1 class="text-2xl font-bold mb-2">{title}</h1>
    <p class="text-gray-600 dark:text-gray-400 mb-6">
      履歴書や提出書類など、容量制限に合わせたいときに使えるPDF圧縮ツールです。画質とのバランスを見ながら、必要な範囲でサイズを調整できます。
    </p>

    <h2 class="text-lg font-semibold mb-2">こんなときに使えます</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-2">
      <li>
        履歴書・職務経歴書をメール添付で送りたい
        <span class="block text-sm">容量制限に合わせつつ、文字の読みやすさを優先できます。</span>
      </li>
      <li>
        学校・保育園・役所にPDF提出が必要
        <span class="block text-sm">◯MB以下の指定がある場合や、スマホスキャンPDFが重いときに便利です。</span>
      </li>
      <li>
        スマホで撮ったPDFが重い
        <span class="block text-sm">写真が多いPDFでも、画質と容量のバランスを取りやすくなります。</span>
      </li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">おすすめの使い方</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>まずは「中」で試す</li>
      <li>文字が潰れる場合は「低（高画質）」へ</li>
      <li>とにかく容量を下げたい場合は「高（高圧縮）」へ</li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">注意事項 / できること・できないこと</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>圧縮後の画質は元に戻せません。元PDFは手元に保存しておくことをおすすめします。</li>
      <li>PDFの内容によってはサイズがあまり小さくならないことがあります。</li>
      <li>重要書類は送信前に内容を確認してからご利用ください。</li>
      <li>個人情報や機密情報を含むPDFは、取り扱いに注意してご利用ください。</li>
      <li>ファイルサイズが大きい場合は圧縮に時間がかかることがあります。</li>
      <li>通信環境によってはアップロードやダウンロードが失敗する場合があります。</li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">データの取り扱い</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>PDFは一時的にアップロードされ、サーバ側で圧縮処理を行います。</li>
      <li>元ファイルは圧縮完了後に削除します。</li>
      <li>圧縮後ファイルはダウンロードのため数時間のみ保存されます。</li>
    </ul>

    <div class="space-y-4">
      <div>
        <label class="block font-medium mb-1" for="pdfFile">PDFファイルを選択</label>
        <div class="flex flex-wrap items-center gap-3">
          <label for="pdfFile" class="inline-flex items-center rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer">
            ファイルを選択
          </label>
          <span id="fileInfo" class="text-sm text-gray-500">未選択</span>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf" class="sr-only" />
      </div>

      <div>
        <label class="block font-medium mb-1" for="level">圧縮レベル</label>
        <div class="flex items-center gap-3">
          <input id="level" type="range" min="1" max="3" step="1" value="2" class="w-56" />
          <span id="levelLabel" class="text-sm text-gray-700 dark:text-gray-300">中</span>
        </div>
        <p class="mt-1 text-xs text-gray-500">低は高画質、 高は高圧縮で容量を小さくします。</p>
      </div>

      <div class="flex items-center gap-3">
        <button id="compressBtn" class="rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 disabled:opacity-50" disabled>
          圧縮を開始
        </button>
        <button id="downloadBtn" class="hidden rounded-md px-4 py-2 bg-blue-600 text-white hover:bg-blue-700">ダウンロード</button>
        <span id="status" class="text-sm text-gray-600 dark:text-gray-400"></span>
      </div>
      <div id="progressText" class="text-xs text-gray-500"></div>

      <details class="mt-2">
        <summary class="cursor-pointer select-none">詳細オプション</summary>
        <div class="mt-2 space-y-2">
          <label class="flex items-center gap-2">
            <input id="removeMetadata" type="checkbox" class="h-4 w-4" checked />
            <span class="text-sm">文書メタデータを削除（可能な場合）</span>
          </label>
          <label class="flex items-center gap-2">
            <input id="grayscale" type="checkbox" class="h-4 w-4" />
            <span class="text-sm">グレースケールに変換（容量を小さく）</span>
          </label>
        </div>
      </details>

      <div id="preview" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    </div>
  </section>

  <script define:vars={{ apiBase }}>
    var API_BASE = apiBase || '';
    function api(path) {
      var b = API_BASE || '';
      if (b && b.charAt(b.length - 1) === '/') b = b.slice(0, -1);
      return b + path;
    }

    var fileInput = document.getElementById('pdfFile');
    var fileInfo = document.getElementById('fileInfo');
    var level = document.getElementById('level');
    var levelLabel = document.getElementById('levelLabel');
    var compressBtn = document.getElementById('compressBtn');
    var downloadBtn = document.getElementById('downloadBtn');
    var pendingDownloadUrl = null;
    var pendingFilename = null;
    var statusEl = document.getElementById('status');
    var progressText = document.getElementById('progressText');
    var preview = document.getElementById('preview');

    function levelText(v) { return (v <= 1 ? '低（高画質）' : (v >= 3 ? '高（高圧縮）' : '中')); }
    if (level && levelLabel) {
      levelLabel.textContent = levelText(Number(level.value));
      level.addEventListener('input', function () { levelLabel.textContent = levelText(Number(level.value)); });
    }

    function formatBytes(bytes) {
      if (!isFinite(bytes)) return '';
      var sizes = ['B','KB','MB','GB'];
      var i = 0;
      while (bytes >= 1024 && i < sizes.length - 1) { bytes /= 1024; i++; }
      var places = (bytes < 10 && i > 0) ? 1 : 0;
      return String(bytes.toFixed(places)) + ' ' + sizes[i];
    }

    if (fileInput) {
      fileInput.addEventListener('change', function () {
        if (preview) preview.innerHTML = '';
        var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (compressBtn) compressBtn.disabled = !f;
        if (fileInfo) fileInfo.textContent = f ? (f.name + ' — ' + formatBytes(f.size)) : '未選択';
        if (statusEl) statusEl.textContent = '';
        if (downloadBtn) downloadBtn.classList.add('hidden');
        if (progressText) progressText.textContent = '';
      });
    }

    function postJSON(url, data) {
      return fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(data)
      }).then(function (res) {
        if (res.ok) return res.json();
        return res.text().then(function (t) {
          var err = new Error('リクエストに失敗しました: ' + res.status + (t ? (' ' + t) : ''));
          err.status = res.status;
          err.body = t;
          throw err;
        });
      });
    }

    function sleep(ms) { return new Promise(function (r) { setTimeout(r, ms); }); }

    async function withBackoff(task, options) {
      options = options || {};
      var retries = (options.retries == null ? 4 : options.retries);
      var base = options.base || 400; // ms
      var factor = options.factor || 2;
      var max = options.max || 5000; // ms
      for (var attempt = 0; attempt <= retries; attempt++) {
        try {
          return await task(attempt + 1);
        } catch (e) {
          var status = e && e.status;
          var retryable = (status === 429) || (status >= 500 && status < 600) || (status == null);
          if (attempt === retries || !retryable) { throw e; }
          var delay = Math.min(max, base * Math.pow(factor, attempt));
          var wait = Math.floor(Math.random() * delay); // full jitter
          if (statusEl) statusEl.textContent = '再試行まで ' + Math.ceil(wait/1000) + ' 秒（' + (attempt+2) + '/' + (retries+1) + ' 回目）';
          await sleep(wait);
        }
      }
    }

    function uploadToS3(url, file, onProgress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('PUT', url);
        xhr.setRequestHeader('Content-Type', file.type || 'application/pdf');
        xhr.upload.onprogress = function (e) {
          if (!e.lengthComputable) return;
          var pct = Math.round((e.loaded / e.total) * 100);
          if (onProgress) onProgress(pct);
        };
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) resolve(null);
          else reject(new Error('アップロードに失敗しました: ' + xhr.status));
        };
        xhr.onerror = function () { reject(new Error('アップロード中に通信エラーが発生しました')); };
        xhr.send(file);
      });
    }

    if (compressBtn) {
      compressBtn.addEventListener('click', function () {
        var f = (fileInput && fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (!f) return;
        if (!API_BASE) {
          if (statusEl) statusEl.textContent = 'APIの設定が見つかりません。PUBLIC_PDF_API_BASE を設定してください。';
          return;
        }
        compressBtn.disabled = true;
        if (statusEl) statusEl.textContent = 'アップロードURLを取得中...';
        if (progressText) progressText.textContent = '';
        withBackoff(function () { return postJSON(api('/sign-upload'), {
          filename: f.name,
          contentType: f.type || 'application/pdf'
        }); }, { retries: 5, base: 500, max: 6000 }).then(function (sign) {
          if (statusEl) statusEl.textContent = 'アップロード中...';
          return uploadToS3(sign.uploadUrl, f, function (pct) {
            if (progressText) progressText.textContent = 'アップロード: ' + pct + '%';
          }).then(function () { return sign; });
        }).then(function (sign) {
          if (statusEl) statusEl.textContent = '圧縮処理を開始中...';
          var rmEl = document.getElementById('removeMetadata');
          var gsEl = document.getElementById('grayscale');
          return withBackoff(function () { return postJSON(api('/compress'), {
            bucket: sign.bucket,
            key: sign.objectKey,
            level: Number(level && level.value || 2),
            removeMetadata: !!(rmEl && rmEl.checked),
            grayscale: !!(gsEl && gsEl.checked)
          }); }, { retries: 5, base: 700, max: 8000 });
        }).then(function (resp) {
          if (resp.downloadUrl && downloadBtn) {
            pendingDownloadUrl = resp.downloadUrl;
            var base = f.name.replace(/\.pdf$/i, '');
            pendingFilename = base + '.compressed.pdf';
            downloadBtn.classList.remove('hidden');
            if (statusEl) statusEl.textContent = '圧縮が完了しました。ダウンロードしてください。';
          } else if (statusEl) {
            statusEl.textContent = '圧縮が完了しましたが、ダウンロード情報を取得できませんでした。';
          }
        }).catch(function (err) {
          console.error(err);
          if (statusEl) statusEl.textContent = 'エラー: ' + (err && err.message || err);
        }).finally(function () {
          compressBtn.disabled = !fileInput || !(fileInput.files && fileInput.files[0]);
        });
      });
    }

    if (downloadBtn) {
      downloadBtn.addEventListener('click', function () {
        if (!pendingDownloadUrl) return;
        if (statusEl) statusEl.textContent = 'ダウンロード準備中...';
        downloadBtn.disabled = true;
        fetch(pendingDownloadUrl, { method: 'GET' })
          .then(function (res) { if (!res.ok) throw new Error('ダウンロードに失敗しました: ' + res.status); return res.blob(); })
          .then(function (blob) {
            var link = document.createElement('a');
            var urlObj = URL.createObjectURL(blob);
            link.href = urlObj;
            if (pendingFilename) link.download = pendingFilename;
            document.body.appendChild(link);
            link.click();
            setTimeout(function () { URL.revokeObjectURL(urlObj); if (link.parentNode) link.parentNode.removeChild(link); }, 1000);
            if (statusEl) statusEl.textContent = 'ダウンロードを開始しました。';
          })
          .catch(function (err) {
            console.error(err);
            if (statusEl) statusEl.textContent = 'エラー: ' + (err && err.message || err);
          })
          .finally(function () { downloadBtn.disabled = false; });
      });
    }
  </script>
</Layout>
