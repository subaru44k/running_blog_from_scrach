---
import Layout from "../layouts/Layout.astro";
const title = "PDF圧縮";
const apiBase = import.meta.env.PUBLIC_PDF_API_BASE || '';
const pageTitle = 'PDF圧縮｜履歴書・提出書類の容量を軽くする';
const pageDescription = '履歴書や提出書類、スマホで作成したPDFの容量を画質とのバランスを見ながら圧縮できます。サーバで圧縮処理を行い、元PDFは短時間のみ保存され一定時間後に自動削除されます。圧縮後ファイルも一定時間のみ保存され、自動削除されます。';
---
<Layout noSidebar pageTitle={pageTitle} metaDescription={pageDescription}>
  <section class="card p-6">
    <h1 class="text-2xl font-bold mb-2">{title}</h1>
    <p class="text-gray-600 dark:text-gray-400 mb-6">
      履歴書や提出書類など、容量制限に合わせたいときに使えるPDF圧縮ツールです。画質とのバランスを見ながら、必要な範囲でサイズを調整できます。
    </p>

    <h2 class="text-lg font-semibold mb-2">こんなときに使えます</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-2">
      <li>
        履歴書・職務経歴書をメール添付で送りたい
        <span class="block text-sm">容量制限に合わせつつ、文字の読みやすさを優先できます。</span>
      </li>
      <li>
        学校・保育園・役所にPDF提出が必要
        <span class="block text-sm">◯MB以下の指定がある場合や、スマホスキャンPDFが重いときに便利です。</span>
      </li>
      <li>
        スマホで撮ったPDFが重い
        <span class="block text-sm">写真が多いPDFでも、画質と容量のバランスを取りやすくなります。</span>
      </li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">おすすめの使い方</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>圧縮後に「高画質 / 標準 / 高圧縮」の3候補が表示されます。</li>
      <li>サイズ制限がある場合は、上限以内の候補を選んでください。</li>
      <li>画質を重視する場合は「高画質」、容量重視なら「高圧縮」がおすすめです。</li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">注意事項・できること／できないこと</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>圧縮後の画質は元に戻せません。元PDFは手元に保存しておくことをおすすめします。</li>
      <li>画像が多いPDFは圧縮効果が出やすい一方、内容によってはサイズがあまり小さくならない場合があります。</li>
      <li>文字中心のPDFは、見た目がほとんど変わらずサイズも大きく変わらないことがあります。</li>
      <li>重要書類は送信・提出前に内容を確認してからご利用ください。</li>
      <li>個人情報や機密情報を含むPDFは、取り扱いに注意してご利用ください。</li>
      <li>ファイルサイズが大きい場合は圧縮に時間がかかることがあります。</li>
      <li>通信環境によってはアップロードやダウンロードが失敗する場合があります。</li>
    </ul>

    <h2 class="text-lg font-semibold mb-2">よくある質問</h2>
    <dl class="text-gray-600 dark:text-gray-400 mb-6 space-y-3">
      <div>
        <dt class="font-medium">Q. なぜ思ったほどサイズが小さくならないのですか？</dt>
        <dd class="text-sm">画像が少ないPDFや、すでに最適化されているPDFは効果が出にくいことがあります。内容によって結果が変わります。</dd>
      </div>
      <div>
        <dt class="font-medium">Q. 画質はどのくらい落ちますか？</dt>
        <dd class="text-sm">圧縮レベルによって変わります。まずは「中」で試し、文字が潰れる場合は「低（高画質）」に戻すと安心です。</dd>
      </div>
      <div>
        <dt class="font-medium">Q. 提出書類に使っても大丈夫ですか？</dt>
        <dd class="text-sm">提出先の指定を満たせる場合に限り利用できます。必ず内容と見え方を確認してから送信してください。</dd>
      </div>
    </dl>

    <h2 class="text-lg font-semibold mb-2">データの取り扱い</h2>
    <ul class="list-disc pl-5 text-gray-600 dark:text-gray-400 mb-6 space-y-1">
      <li>PDFは一時的にアップロードされ、サーバ側で圧縮処理を行います。</li>
      <li>元PDFは短時間のみ保存され、一定時間後に自動的に削除されます。</li>
      <li>圧縮後ファイルも一定時間のみ保存され、その後自動的に削除されます。</li>
    </ul>

    <div class="space-y-4">
      <div>
        <label class="block font-medium mb-1" for="pdfFile">PDFファイルを選択</label>
        <div class="flex flex-wrap items-center gap-3">
          <label for="pdfFile" class="inline-flex items-center rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer">
            ファイルを選択
          </label>
          <span id="fileInfo" class="text-sm text-gray-500">未選択</span>
        </div>
        <input id="pdfFile" type="file" accept="application/pdf" class="sr-only" />
      </div>

      <div>
        <label class="block font-medium mb-1" for="maxSizeMb">上限サイズ（任意）</label>
        <div class="flex items-center gap-3">
          <input id="maxSizeMb" type="number" inputmode="decimal" step="0.1" min="0.1" class="w-40 border rounded px-3 py-2" placeholder="例：5" />
          <span class="text-sm text-gray-700 dark:text-gray-300">MB</span>
        </div>
        <p class="mt-1 text-xs text-gray-500">上限を入れると、条件を満たす候補にバッジが付きます。</p>
      </div>

      <div class="flex items-center gap-3">
        <button id="compressBtn" class="rounded-md px-4 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 disabled:opacity-50" disabled>
          圧縮を開始
        </button>
        <span id="status" class="text-sm text-gray-600 dark:text-gray-400"></span>
      </div>
      <div id="progressText" class="text-xs text-gray-500"></div>

      <details class="mt-2">
        <summary class="cursor-pointer select-none">詳細オプション</summary>
        <div class="mt-2 space-y-2">
          <label class="flex items-center gap-2">
            <input id="removeMetadata" type="checkbox" class="h-4 w-4" checked />
            <span class="text-sm">文書メタデータを削除（可能な場合）</span>
          </label>
          <label class="flex items-center gap-2">
            <input id="grayscale" type="checkbox" class="h-4 w-4" />
            <span class="text-sm">グレースケールに変換（容量を小さく）</span>
          </label>
        </div>
      </details>

      <div id="preview" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    </div>
  </section>

  <script define:vars={{ apiBase }}>
    var API_BASE = apiBase || '';
    function api(path) {
      var b = API_BASE || '';
      if (b && b.charAt(b.length - 1) === '/') b = b.slice(0, -1);
      return b + path;
    }

    var fileInput = document.getElementById('pdfFile');
    var fileInfo = document.getElementById('fileInfo');
    var compressBtn = document.getElementById('compressBtn');
    var statusEl = document.getElementById('status');
    var progressText = document.getElementById('progressText');
    var preview = document.getElementById('preview');
    var maxSizeMb = document.getElementById('maxSizeMb');
    var activeOptions = null;
    var activeBaseName = null;
    var variantsState = [];

    function formatBytes(bytes) {
      if (!isFinite(bytes)) return '';
      var sizes = ['B','KB','MB','GB'];
      var i = 0;
      while (bytes >= 1024 && i < sizes.length - 1) { bytes /= 1024; i++; }
      var places = (bytes < 10 && i > 0) ? 1 : 0;
      return String(bytes.toFixed(places)) + ' ' + sizes[i];
    }

    function formatMb(value) {
      if (!isFinite(value)) return '';
      var rounded = Math.round(value * 10) / 10;
      return (rounded % 1 === 0) ? String(Math.trunc(rounded)) : String(rounded);
    }

    function formatPercent(value) {
      if (!isFinite(value)) return '';
      return String(Math.round(value));
    }

    function parseMaxSizeBytes() {
      if (!maxSizeMb) return null;
      var mb = Number(maxSizeMb.value);
      if (!isFinite(mb) || mb <= 0) return null;
      return mb * 1024 * 1024;
    }

    if (fileInput) {
      fileInput.addEventListener('change', function () {
        if (preview) preview.innerHTML = '';
        var f = (fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (compressBtn) compressBtn.disabled = !f;
        if (fileInfo) fileInfo.textContent = f ? (f.name + ' — ' + formatBytes(f.size)) : '未選択';
        if (statusEl) statusEl.textContent = '';
        if (progressText) progressText.textContent = '';
      });
    }

    function postJSON(url, data) {
      return fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(data)
      }).then(function (res) {
        if (res.ok) return res.json();
        return res.text().then(function (t) {
          var err = new Error('リクエストに失敗しました: ' + res.status + (t ? (' ' + t) : ''));
          err.status = res.status;
          err.body = t;
          throw err;
        });
      });
    }

    function sleep(ms) { return new Promise(function (r) { setTimeout(r, ms); }); }

    async function withBackoff(task, options) {
      options = options || {};
      var retries = (options.retries == null ? 4 : options.retries);
      var base = options.base || 400; // ms
      var factor = options.factor || 2;
      var max = options.max || 5000; // ms
      for (var attempt = 0; attempt <= retries; attempt++) {
        try {
          return await task(attempt + 1);
        } catch (e) {
          var status = e && e.status;
          var retryable = (status === 429) || (status >= 500 && status < 600) || (status == null);
          if (attempt === retries || !retryable) { throw e; }
          var delay = Math.min(max, base * Math.pow(factor, attempt));
          var wait = Math.floor(Math.random() * delay); // full jitter
          if (statusEl) statusEl.textContent = '再試行まで ' + Math.ceil(wait/1000) + ' 秒（' + (attempt+2) + '/' + (retries+1) + ' 回目）';
          await sleep(wait);
        }
      }
    }

    function uploadToS3(url, file, onProgress) {
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('PUT', url);
        xhr.setRequestHeader('Content-Type', file.type || 'application/pdf');
        xhr.upload.onprogress = function (e) {
          if (!e.lengthComputable) return;
          var pct = Math.round((e.loaded / e.total) * 100);
          if (onProgress) onProgress(pct);
        };
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) resolve(null);
          else reject(new Error('アップロードに失敗しました: ' + xhr.status));
        };
        xhr.onerror = function () { reject(new Error('アップロード中に通信エラーが発生しました')); };
        xhr.send(file);
      });
    }

    function downloadSignedUrl(url, filename) {
      if (statusEl) statusEl.textContent = 'ダウンロード準備中...';
      return fetch(url, { method: 'GET' })
        .then(function (res) {
          if (!res.ok) throw new Error('ダウンロードに失敗しました: ' + res.status);
          return res.blob();
        })
        .then(function (blob) {
          var link = document.createElement('a');
          var urlObj = URL.createObjectURL(blob);
          link.href = urlObj;
          if (filename) link.download = filename;
          document.body.appendChild(link);
          link.click();
          setTimeout(function () { URL.revokeObjectURL(urlObj); if (link.parentNode) link.parentNode.removeChild(link); }, 1000);
          if (statusEl) statusEl.textContent = 'ダウンロードを開始しました。';
        });
    }

    function pickRecommendedKey(variants, maxBytes) {
      if (!variants || !variants.length) return null;
      if (!maxBytes) return 'balanced';
      var within = variants.filter(function (v) { return isFinite(v.outputSizeBytes) && v.outputSizeBytes <= maxBytes; });
      if (within.length > 0) {
        var order = ['balanced', 'high_quality', 'high_compression'];
        for (var i = 0; i < order.length; i++) {
          var found = within.find(function (v) { return v.key === order[i]; });
          if (found) return found.key;
        }
      }
      var min = null;
      for (var j = 0; j < variants.length; j++) {
        if (!isFinite(variants[j].outputSizeBytes)) continue;
        if (!min || variants[j].outputSizeBytes < min.outputSizeBytes) min = variants[j];
      }
      return min ? min.key : variants[0].key;
    }

    function renderVariants(variants, originalSizeBytes, maxBytes, baseName) {
      if (!preview) return;
      preview.innerHTML = '';
      var recommendedKey = pickRecommendedKey(variants, maxBytes);
      var suffixMap = { high_quality: 'hq', balanced: 'balanced', high_compression: 'small' };
      var maxMbLabel = maxBytes ? (formatMb(maxBytes / 1024 / 1024) + 'MB以下') : '';

      variants.forEach(function (variant) {
        var card = document.createElement('div');
        card.className = 'border rounded-lg p-4 space-y-2';

        var titleRow = document.createElement('div');
        titleRow.className = 'flex items-center justify-between gap-2';
        var title = document.createElement('div');
        title.className = 'text-base font-semibold';
        title.textContent = variant.labelJa || '';
        titleRow.appendChild(title);

        var badges = document.createElement('div');
        badges.className = 'flex items-center gap-2';
        if (maxBytes && isFinite(variant.outputSizeBytes) && variant.outputSizeBytes <= maxBytes) {
          var okBadge = document.createElement('span');
          okBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-green-100 text-green-800';
          okBadge.textContent = maxMbLabel;
          badges.appendChild(okBadge);
        }
        if (variant.key === recommendedKey) {
          var recBadge = document.createElement('span');
          recBadge.className = 'text-xs px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800';
          recBadge.textContent = 'おすすめ';
          badges.appendChild(recBadge);
        }
        titleRow.appendChild(badges);
        card.appendChild(titleRow);

        var sizeText = document.createElement('div');
        sizeText.className = 'text-sm text-gray-600 dark:text-gray-400';
        if (isFinite(variant.outputSizeBytes)) {
          sizeText.textContent = '圧縮後サイズ: ' + formatBytes(variant.outputSizeBytes);
        } else if (variant.state === 'pending') {
          sizeText.textContent = '圧縮中...';
        } else {
          sizeText.textContent = '圧縮に失敗しました。';
        }
        card.appendChild(sizeText);

        if (isFinite(originalSizeBytes) && originalSizeBytes > 0 && isFinite(variant.outputSizeBytes)) {
          var ratio = (1 - (variant.outputSizeBytes / originalSizeBytes)) * 100;
          var ratioText = document.createElement('div');
          ratioText.className = 'text-sm text-gray-600 dark:text-gray-400';
          ratioText.textContent = '削減率: ' + formatPercent(ratio) + '%';
          card.appendChild(ratioText);
        }

        if (variant.previewUrl) {
          var img = document.createElement('img');
          img.src = variant.previewUrl;
          img.alt = variant.labelJa + 'のプレビュー';
          img.className = 'w-full rounded border';
          card.appendChild(img);
        } else if (variant.state === 'pending') {
          var waiting = document.createElement('div');
          waiting.className = 'text-sm text-gray-500';
          waiting.textContent = 'プレビューを生成中...';
          card.appendChild(waiting);
        } else if (variant.state === 'error') {
          var noPreview = document.createElement('div');
          noPreview.className = 'text-sm text-gray-500';
          noPreview.textContent = 'プレビューは表示できません';
          card.appendChild(noPreview);
        } else {
          var noPreview = document.createElement('div');
          noPreview.className = 'text-sm text-gray-500';
          noPreview.textContent = 'プレビューは準備中';
          card.appendChild(noPreview);
        }

        if (variant.state === 'error' && variant.errorMessage) {
          var errText = document.createElement('div');
          errText.className = 'text-xs text-red-600';
          errText.textContent = 'エラー: ' + variant.errorMessage;
          card.appendChild(errText);
        }

        if (variant.downloadUrl) {
          var btn = document.createElement('button');
          btn.className = 'rounded-md px-3 py-2 bg-blue-600 text-white hover:bg-blue-700';
          btn.textContent = 'ダウンロード';
          btn.dataset.url = variant.downloadUrl || '';
          var suffix = suffixMap[variant.key] || 'compressed';
          btn.dataset.filename = baseName ? (baseName + '.' + suffix + '.pdf') : '';
          btn.addEventListener('click', function () {
            if (!btn.dataset.url) return;
            downloadSignedUrl(btn.dataset.url, btn.dataset.filename || undefined)
              .catch(function (err) {
                console.error(err);
                if (statusEl) statusEl.textContent = 'エラー: ' + (err && err.message || err);
              });
          });
          card.appendChild(btn);
        }

        if (variant.state === 'error' && typeof variant.onRetry === 'function') {
          var retryBtn = document.createElement('button');
          retryBtn.className = 'rounded-md px-3 py-2 ring-1 ring-inset ring-gray-300 dark:ring-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800';
          retryBtn.textContent = '再試行';
          retryBtn.addEventListener('click', function () {
            variant.onRetry();
          });
          card.appendChild(retryBtn);
        }

        preview.appendChild(card);
      });
    }

    if (compressBtn) {
      compressBtn.addEventListener('click', function () {
        var f = (fileInput && fileInput.files && fileInput.files[0]) ? fileInput.files[0] : null;
        if (!f) return;
        if (!API_BASE) {
          if (statusEl) statusEl.textContent = 'APIの設定が見つかりません。PUBLIC_PDF_API_BASE を設定してください。';
          return;
        }
        compressBtn.disabled = true;
        if (statusEl) statusEl.textContent = 'アップロードURLを取得中...';
        if (progressText) progressText.textContent = '';
        if (preview) preview.innerHTML = '';
        withBackoff(function () { return postJSON(api('/sign-upload'), {
          filename: f.name,
          contentType: f.type || 'application/pdf'
        }); }, { retries: 5, base: 500, max: 6000 }).then(function (sign) {
          if (statusEl) statusEl.textContent = 'アップロード中...';
          return uploadToS3(sign.uploadUrl, f, function (pct) {
            if (progressText) progressText.textContent = 'アップロード: ' + pct + '%';
          }).then(function () { return sign; });
        }).then(function (sign) {
          if (statusEl) statusEl.textContent = '圧縮中...（3件中 0件完了）';
          var rmEl = document.getElementById('removeMetadata');
          var gsEl = document.getElementById('grayscale');
          activeOptions = {
            removeMetadata: !!(rmEl && rmEl.checked),
            grayscale: !!(gsEl && gsEl.checked),
          };
          activeBaseName = f.name.replace(/\.pdf$/i, '');
          variantsState = [
            { key: 'high_quality', labelJa: '高画質', level: 1, state: 'pending' },
            { key: 'balanced', labelJa: '標準', level: 2, state: 'pending' },
            { key: 'high_compression', labelJa: '高圧縮', level: 3, state: 'pending' },
          ];
          renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);

          function updateStatus() {
            if (!statusEl) return;
            var doneCount = variantsState.filter(function (v) { return v.state !== 'pending'; }).length;
            statusEl.textContent = '圧縮中...（3件中 ' + doneCount + '件完了）';
          }

          function compressOne(level) {
            return withBackoff(function () {
              return postJSON(api('/compress'), {
                bucket: sign.bucket,
                key: sign.objectKey,
                level: level,
                removeMetadata: activeOptions.removeMetadata,
                grayscale: activeOptions.grayscale,
                keepSource: true
              });
            }, { retries: 5, base: 700, max: 8000 });
          }

          function attachRetry(variant) {
            variant.onRetry = function () {
              variant.state = 'pending';
              variant.errorMessage = null;
              variant.downloadUrl = null;
              variant.outputSizeBytes = NaN;
              variant.previewUrl = null;
              renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
              if (statusEl) statusEl.textContent = '再試行中...';
              compressOne(variant.level).then(function (resp) {
                variant.state = 'success';
                variant.downloadUrl = resp && resp.downloadUrl;
                variant.outputSizeBytes = resp && resp.outputSizeBytes;
                variant.previewUrl = resp && resp.previewUrl;
                renderVariants(variantsState, resp.originalSizeBytes || f.size, parseMaxSizeBytes(), activeBaseName);
              }).catch(function (err) {
                variant.state = 'error';
                variant.errorMessage = (err && err.message) ? err.message : '不明なエラー';
                renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
              }).finally(function () {
                updateStatus();
              });
            };
          }

          variantsState.forEach(function (variant) { attachRetry(variant); });

          var requests = variantsState.map(function (variant) {
            return compressOne(variant.level).then(function (resp) {
              variant.state = 'success';
              variant.downloadUrl = resp && resp.downloadUrl;
              variant.outputSizeBytes = resp && resp.outputSizeBytes;
              variant.previewUrl = resp && resp.previewUrl;
              renderVariants(variantsState, resp.originalSizeBytes || f.size, parseMaxSizeBytes(), activeBaseName);
            }).catch(function (err) {
              variant.state = 'error';
              variant.errorMessage = (err && err.message) ? err.message : '不明なエラー';
              renderVariants(variantsState, f.size, parseMaxSizeBytes(), activeBaseName);
            }).finally(function () {
              updateStatus();
            });
          });

          return Promise.allSettled(requests).then(function () {
            if (statusEl) {
              var successCount = variantsState.filter(function (v) { return v.state === 'success'; }).length;
              if (successCount > 0) {
                statusEl.textContent = '圧縮が完了しました。候補から選んでダウンロードしてください。';
              } else {
                statusEl.textContent = '圧縮に失敗しました。時間をおいて再試行してください。';
              }
            }
          });
        }).then(function (resp) {
          if (resp && resp.downloadUrl) {
            if (preview) {
              preview.innerHTML = '';
              renderVariants([{
                key: 'balanced',
                labelJa: '圧縮結果',
                outputSizeBytes: resp.outputSizeBytes || f.size,
                downloadUrl: resp.downloadUrl,
                previewUrl: null,
                state: 'success'
              }], resp.originalSizeBytes || f.size, parseMaxSizeBytes(), f.name.replace(/\.pdf$/i, ''));
            }
            if (statusEl) statusEl.textContent = '圧縮が完了しました。ダウンロードしてください。';
          } else if (statusEl) {
            statusEl.textContent = '圧縮が完了しましたが、ダウンロード情報を取得できませんでした。';
          }
        }).catch(function (err) {
          console.error(err);
          if (statusEl) statusEl.textContent = 'エラー: ' + (err && err.message || err);
        }).finally(function () {
          compressBtn.disabled = !fileInput || !(fileInput.files && fileInput.files[0]);
        });
      });
    }
  </script>
</Layout>
